<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LostOS: src/kernel/mm/pmm.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LostOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_cbd7f246bdf7dc0a50281a272327e6ed.html">kernel</a></li><li class="navelem"><a class="el" href="dir_80965eb3ba1160063c01e5ec79f497d2.html">mm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pmm.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="pmm_8h_source.html">mm/pmm.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="printf_8h_source.html">debug_utils/printf.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a64c4a1b74b0bf32ba34832c054eb31f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a64c4a1b74b0bf32ba34832c054eb31f1">pushAllPMM</a> (<a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a> m, bool merge)</td></tr>
<tr class="separator:a64c4a1b74b0bf32ba34832c054eb31f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3765ad9c647b697e75cd7fdd35ab8911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a3765ad9c647b697e75cd7fdd35ab8911">popAllPMM</a> ()</td></tr>
<tr class="separator:a3765ad9c647b697e75cd7fdd35ab8911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eca41541cd1fd854545a42d5194389c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a0eca41541cd1fd854545a42d5194389c">findRAMSize</a> (<a class="el" href="multiboot_8h.html#abc47d72689f915831784b5bd3f4c2401">multiboot_info_t</a> *mbt)</td></tr>
<tr class="separator:a0eca41541cd1fd854545a42d5194389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374593dd3e9fd308f426974eba7afc2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a374593dd3e9fd308f426974eba7afc2c">mergePMM</a> (<a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a> toMerge)</td></tr>
<tr class="separator:a374593dd3e9fd308f426974eba7afc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf1c37b91cd445b89356f56887167d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a9cf1c37b91cd445b89356f56887167d0">defragmentPMM</a> (bool original)</td></tr>
<tr class="separator:a9cf1c37b91cd445b89356f56887167d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880478e8fea14ae37c246594be3de679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a880478e8fea14ae37c246594be3de679">sortedInsertPMM</a> (<a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a> m)</td></tr>
<tr class="separator:a880478e8fea14ae37c246594be3de679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137be8a22aa0ceb14ec8175f132df6c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a137be8a22aa0ceb14ec8175f132df6c7">sortPMM</a> ()</td></tr>
<tr class="separator:a137be8a22aa0ceb14ec8175f132df6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38d3119cf7271bddb0e001d53e2129b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#ab38d3119cf7271bddb0e001d53e2129b">pAllocPage</a> ()</td></tr>
<tr class="separator:ab38d3119cf7271bddb0e001d53e2129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1339a5075397c7100f01c9b0ecf3d886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a1339a5075397c7100f01c9b0ecf3d886">pFreePage</a> (void *addr)</td></tr>
<tr class="separator:a1339a5075397c7100f01c9b0ecf3d886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e5630dfe47d73f3a54d4d47574c3da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a80e5630dfe47d73f3a54d4d47574c3da">firstFit</a> (uint32_t <a class="el" href="gdt_8h.html#aaba88b24a21a6c70c895c0d55f4a69a0">size</a>)</td></tr>
<tr class="separator:a80e5630dfe47d73f3a54d4d47574c3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bc0be58c79c7407b56bf050276c5fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#ad3bc0be58c79c7407b56bf050276c5fd">roundPageAligned</a> (uint32_t n)</td></tr>
<tr class="separator:ad3bc0be58c79c7407b56bf050276c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc059dc84d1d73d5388c0ffe3a3527b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a0fc059dc84d1d73d5388c0ffe3a3527b">pAllocPages</a> (uint32_t <a class="el" href="gdt_8h.html#aaba88b24a21a6c70c895c0d55f4a69a0">size</a>)</td></tr>
<tr class="separator:a0fc059dc84d1d73d5388c0ffe3a3527b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbd902fc2b911df2deb1bf7d1683619"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a9dbd902fc2b911df2deb1bf7d1683619">pFreePages</a> (void *addr, uint32_t <a class="el" href="gdt_8h.html#aaba88b24a21a6c70c895c0d55f4a69a0">size</a>)</td></tr>
<tr class="separator:a9dbd902fc2b911df2deb1bf7d1683619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145054299fcb2ac35423dd472a39079a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a145054299fcb2ac35423dd472a39079a">checkPD</a> (uint32_t pd_start, uint32_t pd_end, <a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a> m)</td></tr>
<tr class="separator:a145054299fcb2ac35423dd472a39079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226ae979acb63b841fc6d1ace18f771a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a226ae979acb63b841fc6d1ace18f771a">checkBoundaries</a> (uint32_t pd_start, uint32_t pd_end, uint32_t length, uint32_t base_addr)</td></tr>
<tr class="separator:a226ae979acb63b841fc6d1ace18f771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864c0a7e14f8e4bd05d55cc893accda8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a864c0a7e14f8e4bd05d55cc893accda8">init_pmm</a> (<a class="el" href="multiboot_8h.html#abc47d72689f915831784b5bd3f4c2401">multiboot_info_t</a> *mbt, uint32_t *pd)</td></tr>
<tr class="separator:a864c0a7e14f8e4bd05d55cc893accda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a976e76d230cf67e977eda36e85e74536"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm_8c.html#a976e76d230cf67e977eda36e85e74536">defrag</a> = false</td></tr>
<tr class="separator:a976e76d230cf67e977eda36e85e74536"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a226ae979acb63b841fc6d1ace18f771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226ae979acb63b841fc6d1ace18f771a">&#9670;&nbsp;</a></span>checkBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void checkBoundaries </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pd_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pd_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the memory map with some overlap controls. (+ = free memory; - = [used memory])</p>
<p>1) [GRUB] +++++++ [PHYS] +++++++-&mdash;</p>
<p>2) [GRUB] +++++++ [PHYS] -&mdash;+++++++</p>
<p>3) [GRUB] +++++++ [PHYS] +++++-&mdash;</p>
<p>4) [GRUB] +++++++ [PHYS] -&mdash;+++++</p>
<p>5) [GRUB] +++++++++++ [PHYS] +++++-&mdash;++. </p>

</div>
</div>
<a id="a145054299fcb2ac35423dd472a39079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145054299fcb2ac35423dd472a39079a">&#9670;&nbsp;</a></span>checkPD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool checkPD </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pd_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pd_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Little boundary check for the BootPageDirectory. It is just 4KB but I need to make sure. </p>

</div>
</div>
<a id="a9cf1c37b91cd445b89356f56887167d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf1c37b91cd445b89356f56887167d0">&#9670;&nbsp;</a></span>defragmentPMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void defragmentPMM </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is going to check for every struct, if it is possible to merge with other.</p>
<p>This algorithm has O(n^2) (I think?) so be careful when to call it. For now it is called when the _stack is half the dimension of the worst case scenario. Choices are:</p><ol type="1">
<li>when you call free() (when you push to the free _stack)</li>
<li>when the _stack size reaches its limit (4Mb sounds reasonable on a 4G machine)</li>
<li>whenever you schedule the idle task </li>
</ol>

</div>
</div>
<a id="a0eca41541cd1fd854545a42d5194389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eca41541cd1fd854545a42d5194389c">&#9670;&nbsp;</a></span>findRAMSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int findRAMSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="multiboot_8h.html#abc47d72689f915831784b5bd3f4c2401">multiboot_info_t</a> *&#160;</td>
          <td class="paramname"><em>mbt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get and anylize the GRUB memory map to count the RAM size. </p>
<p>If the bit 0 is set, it is possible to safely refer to mbd-&gt;mem_lower for conventional memory and mbd-&gt;mem_upper for high memory. Both are given in kibibytes, i.e. blocks of 1024 bytes each.</p>
<p>Otherwise bit 6 in the flags uint16_t is set, then the mmap_* fields are valid, and indicate the address and length of a buffer containing a memory map of the machine provided by the BIOS</p>
<p>Finds the worst case scenario for the _stack (for a 4GB RAM == 8MB).</p>
<p>I need to find the number (so the dimension) of the possible entries on the stack. Then I divide it in half to preserve some memory. When it is reached, defrag is going to be used.</p>

</div>
</div>
<a id="a80e5630dfe47d73f3a54d4d47574c3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e5630dfe47d73f3a54d4d47574c3da">&#9670;&nbsp;</a></span>firstFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a> firstFit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses a First-Fit recursive technique. </p>

</div>
</div>
<a id="a864c0a7e14f8e4bd05d55cc893accda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864c0a7e14f8e4bd05d55cc893accda8">&#9670;&nbsp;</a></span>init_pmm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_pmm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="multiboot_8h.html#abc47d72689f915831784b5bd3f4c2401">multiboot_info_t</a> *&#160;</td>
          <td class="paramname"><em>mbt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To implement the physical memory manager something to hold all the free addressed is needed. I'm using a run-length encoded _stack: this technique constists in pushing the address and the number of pages all at once. This has several advantages:</p><ol type="1">
<li>it requires considerably less memory</li>
<li>it's trivial to fill up the initial _stack from E820 data as it uses the same format :-)</li>
<li>you can search for entries with more pages if you really want to allocate contiguous physical pages</li>
</ol>
<p>At this moment the real page size is 4MB still, but in the initialization of the Virtual Memory Manager it's gonna switch to 4KB. </p>
<p>If the memory sector is not reserved or the address is below 1MB, exclude it. GRUB's mmap doesn't include some stuff that's mapped to memory below 1MB.</p>

</div>
</div>
<a id="a374593dd3e9fd308f426974eba7afc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374593dd3e9fd308f426974eba7afc2c">&#9670;&nbsp;</a></span>mergePMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mergePMM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a>&#160;</td>
          <td class="paramname"><em>toMerge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab38d3119cf7271bddb0e001d53e2129b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38d3119cf7271bddb0e001d53e2129b">&#9670;&nbsp;</a></span>pAllocPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pAllocPage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface Function.</p>
<p>This function allocates a page (WILL BE 4K ALIGNED) and returns the address. </p>

</div>
</div>
<a id="a0fc059dc84d1d73d5388c0ffe3a3527b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc059dc84d1d73d5388c0ffe3a3527b">&#9670;&nbsp;</a></span>pAllocPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pAllocPages </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface Function.</p>
<p>This function allocates a wanted size (NOT NUMBER OF PAGES - BYTES). It uses the technique called "First-Fit". It's faster but causes fragmentation. While pushing in the _stack there are various controls to merge and an "emergency" function when the _stack is too big, so we're safe. </p>

</div>
</div>
<a id="a1339a5075397c7100f01c9b0ecf3d886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1339a5075397c7100f01c9b0ecf3d886">&#9670;&nbsp;</a></span>pFreePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pFreePage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface Function.</p>
<p>This function frees a page, returning true or false if it finished well. </p>

</div>
</div>
<a id="a9dbd902fc2b911df2deb1bf7d1683619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbd902fc2b911df2deb1bf7d1683619">&#9670;&nbsp;</a></span>pFreePages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pFreePages </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface Function.</p>
<p>This function frees memory from the address addr for size. </p>

</div>
</div>
<a id="a3765ad9c647b697e75cd7fdd35ab8911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3765ad9c647b697e75cd7fdd35ab8911">&#9670;&nbsp;</a></span>popAllPMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a> popAllPMM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function pops the first struct of address + nContiguousPages off the _stack. </p>

</div>
</div>
<a id="a64c4a1b74b0bf32ba34832c054eb31f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c4a1b74b0bf32ba34832c054eb31f1">&#9670;&nbsp;</a></span>pushAllPMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pushAllPMM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function pushes a struct of address + nContiguousPages onto the _stack. The _stack must be ordered from the bigger address (on top) to the smaller. </p>

</div>
</div>
<a id="ad3bc0be58c79c7407b56bf050276c5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bc0be58c79c7407b56bf050276c5fd">&#9670;&nbsp;</a></span>roundPageAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t roundPageAligned </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the bigger 4KB aligned size.</p>
<p>(i. e. for 315 Byte will return 4KB, while for 16387 Byte will return 20K) </p>

</div>
</div>
<a id="a880478e8fea14ae37c246594be3de679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880478e8fea14ae37c246594be3de679">&#9670;&nbsp;</a></span>sortedInsertPMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sortedInsertPMM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pmm_8h.html#a56fc0f2bfc4430cfd99522588a0c6878">free_mem_t</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert in sorted order. </p>

</div>
</div>
<a id="a137be8a22aa0ceb14ec8175f132df6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137be8a22aa0ceb14ec8175f132df6c7">&#9670;&nbsp;</a></span>sortPMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sortPMM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive function that sorts the _stack. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a976e76d230cf67e977eda36e85e74536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976e76d230cf67e977eda36e85e74536">&#9670;&nbsp;</a></span>defrag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool defrag = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
