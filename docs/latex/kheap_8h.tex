\hypertarget{kheap_8h}{}\section{src/include/mm/kheap.h File Reference}
\label{kheap_8h}\index{src/include/mm/kheap.\+h@{src/include/mm/kheap.\+h}}
{\ttfamily \#include $<$system.\+h$>$}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct__kheapHeader}{\+\_\+kheap\+Header}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{kheap_8h_ae6d18df3767507402fc452d66e28c027}{K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}~0x10000000
\begin{DoxyCompactList}\small\item\em The maximum length of the heap -\/ 256\+MB. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{struct__kheapHeader}{\+\_\+kheap\+Header} \hyperlink{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}{kheap\+Header}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{kheap_8h_a755a69ff831b6e23a808dcf4b9944854}{init\+\_\+kheap} ()
\item 
void $\ast$ \hyperlink{kheap_8h_afec98775e8113dc6d98f75a582c3646f}{kmalloc} (uint32\+\_\+t \hyperlink{gdt_8h_aaba88b24a21a6c70c895c0d55f4a69a0}{size})
\begin{DoxyCompactList}\small\item\em Function to allocate the heap for the kernel. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{kheap_8h_abcad5693e10bd77d4275c1f8c9cb5cd7}{kcalloc} (uint32\+\_\+t n, uint32\+\_\+t \hyperlink{gdt_8h_aaba88b24a21a6c70c895c0d55f4a69a0}{size})
\item 
void $\ast$ \hyperlink{kheap_8h_a3142cd9d94e09705bb137b527805004a}{krealloc} (void $\ast$ptr, uint32\+\_\+t new\+Size)
\item 
void $\ast$ \hyperlink{kheap_8h_a8ff196f7bd88124197de662bde0eb639}{kfree} (void $\ast$addr)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{kheap_8h_ae6d18df3767507402fc452d66e28c027}\label{kheap_8h_ae6d18df3767507402fc452d66e28c027}} 
\index{kheap.\+h@{kheap.\+h}!K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH@{K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}}
\index{K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH@{K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}{KHEAP\_LENGTH}}
{\footnotesize\ttfamily \#define K\+H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH~0x10000000}



The maximum length of the heap -\/ 256\+MB. 



\subsection{Typedef Documentation}
\mbox{\Hypertarget{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}\label{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}} 
\index{kheap.\+h@{kheap.\+h}!kheap\+Header@{kheap\+Header}}
\index{kheap\+Header@{kheap\+Header}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kheap\+Header}{kheapHeader}}
{\footnotesize\ttfamily typedef struct \hyperlink{struct__kheapHeader}{\+\_\+kheap\+Header}  \hyperlink{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}{kheap\+Header}}

This structure represent a block inside the linked list of the heap. (It really is only a contiguous block of memory) It is based in the header of the chunk. Thus, when returned, it is important to remember to add sizeof(kheap\+Header); and when a pointer is received, subtract it. 

\subsection{Function Documentation}
\mbox{\Hypertarget{kheap_8h_a755a69ff831b6e23a808dcf4b9944854}\label{kheap_8h_a755a69ff831b6e23a808dcf4b9944854}} 
\index{kheap.\+h@{kheap.\+h}!init\+\_\+kheap@{init\+\_\+kheap}}
\index{init\+\_\+kheap@{init\+\_\+kheap}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{init\+\_\+kheap()}{init\_kheap()}}
{\footnotesize\ttfamily void init\+\_\+kheap (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Initialize kernel heap.

This is done with a linked list. The starting address will be after the P\+MM stack. \mbox{\Hypertarget{kheap_8h_abcad5693e10bd77d4275c1f8c9cb5cd7}\label{kheap_8h_abcad5693e10bd77d4275c1f8c9cb5cd7}} 
\index{kheap.\+h@{kheap.\+h}!kcalloc@{kcalloc}}
\index{kcalloc@{kcalloc}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kcalloc()}{kcalloc()}}
{\footnotesize\ttfamily void$\ast$ kcalloc (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n,  }\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})}

This is used to dynamically allocate the specified number of blocks of memory of the specified type. It initializes each block with a default value ‘0’.


\begin{DoxyParams}{Parameters}
{\em n} & Number of elements \\
\hline
{\em size} & Size of the element\textquotesingle{}s type (sizeof())\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Allocated pointer or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{kheap_8h_a8ff196f7bd88124197de662bde0eb639}\label{kheap_8h_a8ff196f7bd88124197de662bde0eb639}} 
\index{kheap.\+h@{kheap.\+h}!kfree@{kfree}}
\index{kfree@{kfree}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kfree()}{kfree()}}
{\footnotesize\ttfamily void$\ast$ kfree (\begin{DoxyParamCaption}\item[{void $\ast$}]{addr }\end{DoxyParamCaption})}

This is used to dynamically de-\/allocate the memory. The memory allocated using functions malloc() and calloc() is not de-\/allocated on their own. Hence the free() method is used, whenever the dynamic memory allocation takes place. It helps to reduce wastage of memory by freeing it.


\begin{DoxyParams}{Parameters}
{\em addr} & Address to free.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The freed address or N\+U\+LL. 
\end{DoxyReturn}
\mbox{\Hypertarget{kheap_8h_afec98775e8113dc6d98f75a582c3646f}\label{kheap_8h_afec98775e8113dc6d98f75a582c3646f}} 
\index{kheap.\+h@{kheap.\+h}!kmalloc@{kmalloc}}
\index{kmalloc@{kmalloc}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kmalloc()}{kmalloc()}}
{\footnotesize\ttfamily void$\ast$ kmalloc (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})}



Function to allocate the heap for the kernel. 

A heap is a vital component of both application programs and the kernel. It is also generally superseded by a higher level of memory management that deals with larger chunks of memory. For most operating systems memory will be allocated based on pages or other large chunks.

This is used to dynamically allocate a single large block of memory with the specified size. It returns a pointer of type void which can be cast into a pointer of any form.


\begin{DoxyParams}{Parameters}
{\em size} & Size (in bytes) to be allocated.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Allocated pointer 
\end{DoxyReturn}
\mbox{\Hypertarget{kheap_8h_a3142cd9d94e09705bb137b527805004a}\label{kheap_8h_a3142cd9d94e09705bb137b527805004a}} 
\index{kheap.\+h@{kheap.\+h}!krealloc@{krealloc}}
\index{krealloc@{krealloc}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{krealloc()}{krealloc()}}
{\footnotesize\ttfamily void$\ast$ krealloc (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{uint32\+\_\+t}]{new\+Size }\end{DoxyParamCaption})}

This is used to dynamically change the memory allocation of a previously allocated memory. In other words, if the memory previously allocated with the help of malloc or calloc is insufficient, realloc can be used to dynamically re-\/allocate memory.


\begin{DoxyParams}{Parameters}
{\em ptr} & Pointer to reallocate \\
\hline
{\em new\+Size} & New size\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
New pointer or N\+U\+LL 
\end{DoxyReturn}
