\hypertarget{kheap_8h}{}\section{src/include/mm/kheap.h File Reference}
\label{kheap_8h}\index{src/include/mm/kheap.\+h@{src/include/mm/kheap.\+h}}
{\ttfamily \#include $<$system.\+h$>$}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct__kheapHeader}{\+\_\+kheap\+Header}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{kheap_8h_adcac6cf27d536ffab0f05f77872e7c69}{H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}~0x10000000
\begin{DoxyCompactList}\small\item\em The maximum length of the heap -\/ 256\+MB. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{struct__kheapHeader}{\+\_\+kheap\+Header} \hyperlink{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}{kheap\+Header}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{kheap_8h_a755a69ff831b6e23a808dcf4b9944854}{init\+\_\+kheap} ()
\item 
void $\ast$ \hyperlink{kheap_8h_afec98775e8113dc6d98f75a582c3646f}{kmalloc} (uint32\+\_\+t \hyperlink{gdt_8h_aaba88b24a21a6c70c895c0d55f4a69a0}{size})
\begin{DoxyCompactList}\small\item\em Function to allocate the heap for the kernel. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{kheap_8h_abcad5693e10bd77d4275c1f8c9cb5cd7}{kcalloc} (uint32\+\_\+t n, uint32\+\_\+t \hyperlink{gdt_8h_aaba88b24a21a6c70c895c0d55f4a69a0}{size})
\item 
void $\ast$ \hyperlink{kheap_8h_a3142cd9d94e09705bb137b527805004a}{krealloc} (void $\ast$ptr, uint32\+\_\+t new\+Size)
\item 
void $\ast$ \hyperlink{kheap_8h_a8ff196f7bd88124197de662bde0eb639}{kfree} (void $\ast$addr)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{kheap_8h_adcac6cf27d536ffab0f05f77872e7c69}\label{kheap_8h_adcac6cf27d536ffab0f05f77872e7c69}} 
\index{kheap.\+h@{kheap.\+h}!H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH@{H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}}
\index{H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH@{H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH}{HEAP\_LENGTH}}
{\footnotesize\ttfamily \#define H\+E\+A\+P\+\_\+\+L\+E\+N\+G\+TH~0x10000000}



The maximum length of the heap -\/ 256\+MB. 



\subsection{Typedef Documentation}
\mbox{\Hypertarget{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}\label{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}} 
\index{kheap.\+h@{kheap.\+h}!kheap\+Header@{kheap\+Header}}
\index{kheap\+Header@{kheap\+Header}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kheap\+Header}{kheapHeader}}
{\footnotesize\ttfamily typedef struct \hyperlink{struct__kheapHeader}{\+\_\+kheap\+Header}  \hyperlink{kheap_8h_aecdf894eef66106f9a4ff67c70d1d3c6}{kheap\+Header}}

This structure represent a block inside the linked list of the heap. (It really is only a contiguous block of memory) It is based in the header of the chunk. Thus, when returned, it is important to remember to add sizeof(kheap\+Header); and when a pointer is received, subtract it. 

\subsection{Function Documentation}
\mbox{\Hypertarget{kheap_8h_a755a69ff831b6e23a808dcf4b9944854}\label{kheap_8h_a755a69ff831b6e23a808dcf4b9944854}} 
\index{kheap.\+h@{kheap.\+h}!init\+\_\+kheap@{init\+\_\+kheap}}
\index{init\+\_\+kheap@{init\+\_\+kheap}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{init\+\_\+kheap()}{init\_kheap()}}
{\footnotesize\ttfamily void init\+\_\+kheap (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Initialize kernel heap.

This is done with a linked list. The starting address will be after the P\+MM stack. \mbox{\Hypertarget{kheap_8h_abcad5693e10bd77d4275c1f8c9cb5cd7}\label{kheap_8h_abcad5693e10bd77d4275c1f8c9cb5cd7}} 
\index{kheap.\+h@{kheap.\+h}!kcalloc@{kcalloc}}
\index{kcalloc@{kcalloc}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kcalloc()}{kcalloc()}}
{\footnotesize\ttfamily void$\ast$ kcalloc (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n,  }\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})}

\mbox{\Hypertarget{kheap_8h_a8ff196f7bd88124197de662bde0eb639}\label{kheap_8h_a8ff196f7bd88124197de662bde0eb639}} 
\index{kheap.\+h@{kheap.\+h}!kfree@{kfree}}
\index{kfree@{kfree}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kfree()}{kfree()}}
{\footnotesize\ttfamily void$\ast$ kfree (\begin{DoxyParamCaption}\item[{void $\ast$}]{addr }\end{DoxyParamCaption})}

\mbox{\Hypertarget{kheap_8h_afec98775e8113dc6d98f75a582c3646f}\label{kheap_8h_afec98775e8113dc6d98f75a582c3646f}} 
\index{kheap.\+h@{kheap.\+h}!kmalloc@{kmalloc}}
\index{kmalloc@{kmalloc}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{kmalloc()}{kmalloc()}}
{\footnotesize\ttfamily void$\ast$ kmalloc (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})}



Function to allocate the heap for the kernel. 

A heap is a vital component of both application programs and the kernel. It is also generally superseded by a higher level of memory management that deals with larger chunks of memory. For most operating systems memory will be allocated based on pages or other large chunks.

This is used to dynamically allocate a single large block of memory with the specified size. It returns a pointer of type void which can be cast into a pointer of any form.


\begin{DoxyParams}{Parameters}
{\em size} & Size (in bytes) to be allocated.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Allocated pointer 
\end{DoxyReturn}
\mbox{\Hypertarget{kheap_8h_a3142cd9d94e09705bb137b527805004a}\label{kheap_8h_a3142cd9d94e09705bb137b527805004a}} 
\index{kheap.\+h@{kheap.\+h}!krealloc@{krealloc}}
\index{krealloc@{krealloc}!kheap.\+h@{kheap.\+h}}
\subsubsection{\texorpdfstring{krealloc()}{krealloc()}}
{\footnotesize\ttfamily void$\ast$ krealloc (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{uint32\+\_\+t}]{new\+Size }\end{DoxyParamCaption})}

